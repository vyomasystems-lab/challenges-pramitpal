# Level1 Design2 Verification

The verification environment is setup using [Vyoma's UpTickPro](https://vyomasystems.com) provided for the hackathon.

![gitpod ss2](https://user-images.githubusercontent.com/41202066/182040040-be1ed5a3-70d2-4b5b-bf00-9e4b7825cc40.png)

## Verification Environment

The [CoCoTb](https://www.cocotb.org/) based Python test is developed as explained. The test drives inputs to the Design Under Test (seq_detect_1011 module here) which takes in 3 inputs ie. *inp_bit*, *clk* and *reset* and gives output through port *seq_seen*

The clock required for this dut is generated by 
```
    clock = Clock(dut.clk, 10, units="us")  # Create a 10us period clock on port clk
    cocotb.start_soon(clock.start())        # Start the clock
```
The reset is triggered by assigning 1 to the *reset* input port after getting synchronized with the clock pulses
```
    # reset
    dut.reset.value = 1
    await FallingEdge(dut.clk)  
    dut.reset.value = 0
    await FallingEdge(dut.clk)
```
The sequence of bitstream is send to the dut bit by bit for a test sequence by 
```
    #loop through each bit in test_sequence
    for i in range(len(test_sequence)):
        dut.inp_bit.value=int(test_sequence[i])
        await FallingEdge(dut.clk)
        output.append(dut.seq_seen.value.integer)
```
The bit sequence to be sent to the dut is stored in the array *test_sequence*.
```
    test_sequence='11111111011000010101111011'
```
For the two tests deviced namely the fixed sequence test and the random sequence test the test_sequence is declared as
```
    test_sequence='11111111011000010101111011'
```
and 
```
    # Create random test sequence
    n=uuid.uuid1().int*198
    s=format(n, '0128b')
    test_sequence=s
```
respectively. 

The assert statement is used for comparing the expected output to the observed output from the dut.
If the design is error free the assert statement does not raise any assertion error and the dut passes all tests successfully.
As the dut has some bugs in it, the following error is seen:
```
running fixed_test_seq_bug1 (1/2)
output expected = 00000000001000000000100001, output got = 00000000000000000000000000
assert output_str==expected_output_str,'Expected Output is not same as Output'
                     AssertionError: Expected Output is not same as Output
```
```
running random_test_seq_bug1 (2/2)
####Random Test Sequence=110111111000101101111110110011111000011100010101001010111011101110001100010000000110101000111011011111000100010000000110110101001100110 ######
 assert output_str==expected_output_str,'Expected Output is not same as Output'
                      AssertionError: Expected Output is not same as Output
 ```
## Test Scenario **(Important)**
- Fixed value Test:
- test_sequence=11111111011000010101111011 
- Test input: 
```
    #loop through each bit in test_sequence
    for i in range(len(test_sequence)):
        dut.inp_bit.value=int(test_sequence[i])
```                  
- Expected Sequence: seq_seen = 00000000001000000000100001
- Observed Output in the DUT dut.seq_seen=00000000000000000000000000

- Random value Test:
- A random 128-bit long sequence of 0 and 1 is generated and fed to the *inp_bit* of the dut
-test_sequence=110111111000101101111110110011111000011100010101001010111011101110001100010000000110101000111011011111000100010000000110110101001100110

- Test input: 
```
    #loop through each bit in test_sequence
    for i in range(len(test_sequence)):
        dut.inp_bit.value=int(test_sequence[i])
```                  
- Expected Sequence: seq_seen = 00000000001000000000100001
- Observed Output in the DUT dut.seq_seen=00000000000000000000000000

Output mismatches for the above inputs proving that there is a design bug. It can be observed that the dut has errors in detecting overlapping input sequences. By analyzing the verilog design it is clear that the dut is a overlapping Moore finite state machine for detecting 1011 overlapping bit sequence. 

## Design Bug
Based on the above test input and analysing the design, we see the following

```
      SEQ_1:
      begin
        if(inp_bit == 1)
          next_state = IDLE; //==> here is bug
        else
          next_state = SEQ_10;
```
```
      SEQ_101:
      begin
        if(inp_bit == 1)
          next_state = SEQ_1011;
        else
          next_state = IDLE;//==>bug
      end
```
```
      SEQ_1011:
      begin
        next_state = IDLE; //===> here is the bug
      end
```
For the seq_detect_1011 design, the next states for cases *SEQ_1*, *SEQ_101* and *SEQ_1011* has faulty next states, which has been shown above. The correct next_state values for each of these three cases are as follows:
```
      SEQ_1:
      begin
        if(inp_bit == 1)
          next_state = SEQ_1;//corrected
        else
          next_state = SEQ_10;
      end
```
```
      SEQ_101:
      begin
        if(inp_bit == 1)
          next_state = SEQ_1011;
        else
          next_state = SEQ_10; //corrected
      end
```
```
      SEQ_1011:
      begin               //corrected
        if (inp_bit==0)
          next_state = SEQ_10;
        else
          next_state = SEQ_1; 
      end
```
## Design Fix
Updating the design and re-running the test makes the test pass.

![image](https://user-images.githubusercontent.com/110148281/181808597-6e655def-2282-4ce4-8fcf-da6091f34591.png)


The updated design is checked in as seq_detect_1011.v in *correct_design* directory in *level1_design2*

## Verification Strategy
The verification method is divided into two parts, namely a random input test sequence and a fixed input test sequence.
In the random input test a 128-bit long bit sequence is generated. Each bits of that sequence is then sent one by one to the *inp_bit* port for each clock pulse. After asigning each bit, the output from the *seq_seen* port is appended to a list for checking if expected output matches observed output.

In the fixed input test a 26-bit long bit sequence is fixed. Each bits of that sequence is then sent one by one to the *inp_bit* port for each clock pulse. After asigning each bit, the output from the *seq_seen* port is appended to a list for checking if expected output matches observed output.

In each test an assert statement checks if the expected output matches the observed dut output. If it does not match, then it raises an assertion error, resulting in the failure of the test.

The figure below shows the failing tests.
![image](https://user-images.githubusercontent.com/110148281/181808450-9c10ff4c-51fc-449b-b06d-76e08e588b1e.png)

## Is the verification complete ?
Yes.
After correcting the bugs in the design by making some corrections 
both the tests pass with zero errors. Thus the verification is complete and all the bugs are detected.
```
      SEQ_1:
      begin
        if(inp_bit == 1)
          next_state = SEQ_1;//corrected
        else
          next_state = SEQ_10;
      end
```
```
      SEQ_101:
      begin
        if(inp_bit == 1)
          next_state = SEQ_1011;
        else
          next_state = SEQ_10; //corrected
      end
```
```
      SEQ_1011:
      begin               //corrected
        if (inp_bit==0)
          next_state = SEQ_10;
        else
          next_state = SEQ_1; 
      end
```
The bugs in the sequence detector has been captured and the corrected bug free design is stored in correct_design directory.
