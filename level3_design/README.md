# Level3 Design Verification

The verification environment is setup using [Vyoma's UpTickPro](https://vyomasystems.com) provided for the hackathon.

![gitpod ss2](https://user-images.githubusercontent.com/41202066/182039952-0cf50802-d115-4e40-b229-89c6aad7ab86.png)

## Verification Environment

The [CoCoTb](https://www.cocotb.org/) based Python test is developed as explained. The test drives inputs to the Design Under Test (input_capture module here) which takes in clock through *clk* and input signal through *sig* port. The dut gives 8-bit value of the timestamped captured input signal through *val* output port. For each input signal captured, the dut outputs a timestamped value and sets an interrupt flag through the *intFlag* port.

The timestamping of the captured signal is done through a counter module which counts from 0 to 255 for each clock cycle.

The clock is generated by:
```
# clock
clock = Clock(dut.ct.clk, 10, units="ns")  # Create a 10us period clock on port clk
cocotb.start_soon(clock.start())  # Start the clock
```
To check the reset functionality of the counter module the following code is executed
```
# reset the counter to start
await RisingEdge(dut.ct.clk)
dut.ct.reset.value = 1
await RisingEdge(dut.ct.clk)
dut.ct.reset.value = 0
```
To check if the counter is counting correctly:
```
dut.ct.reset.value = 0
await RisingEdge(dut.ct.clk)
first=dut.ct.count.value
await RisingEdge(dut.ct.clk)
second=dut.ct.count.value
await RisingEdge(dut.ct.clk)
third=dut.ct.count.value
```
Checking the input_capture module functionality
```
    InterruptFlag_before_signal = dut.intFlag.value
    await RisingEdge(dut.ct.clk)
    dut.sig.value = 1
    await Timer(1) 
    current_count=dut.ct.count.value
    current_sig_val=dut.val.value
    InterruptFlag_after_signal = dut.intFlag.value
    await RisingEdge(dut.ct.clk)
    dut.sig.value = 0
```
Checking Interrupt flag by
```
# checking Interrupt Flag Reset
    await RisingEdge(dut.clk)
    dut.rstIntFlag.value=1
    await Timer(1)
    InterruptFlag_after_signal_after_reset=dut.intFlag.value
```

To check whether the input capture is working correctly the *sig* line is set after an arbitrary clock rising edge. The if statement is used to compare the dut's captured *val* register with the current count value of the counter module. If these values differ, an error is detected and a counter variable starts to count, how many times an error is detected.

To raise an assertion error, the assert statement is used for comparing the error counter to 0.
If the design is error free the error counter must have 0 errors, but in this case there are few errors which can be seen from the output.
The following error is seen:
- Counter module Test
```
 0.00ns INFO     running test_counter_block (1/2)
    40.00ns INFO     ##### Counter Test ########
    40.00ns INFO     Counter Reset OK
    40.00ns INFO     Decrement counting-- ERROR
    40.00ns INFO     test_counter_block failed
                     Traceback (most recent call last):
                       File "/workspace/challenges-pramitpal/level3_design/test_input_capture.py", line 65, in test_counter_block
                         assert errors == 0, f'There are {errors} faults, in Counter Module'
                     AssertionError: There are 1 faults, in Counter Module
```
- Input Capture Module Test
```
40.00ns INFO     running test_input_capture_module (2/2)
    60.00ns INFO     Signal input Capture fault-- ERROR
    70.00ns INFO     Val Register reset fault-- ERROR
    70.00ns INFO     Interrupt Flag functioning -- OK
    80.00ns INFO     Interrupt Flag Reset functioning -- ERROR
    80.00ns INFO     test_input_capture_module failed
                     Traceback (most recent call last):
                       File "/workspace/challenges-pramitpal/level3_design/test_input_capture.py", line 126, in test_input_capture_module
                         assert errors ==0,f'There are {errors} faults for Signal Input Capture'
                     AssertionError: There are 3 faults for Signal Input Capture
```

## Test Scenario **(Important)**
- Counter Module Test:
  - Immediately after reset ``*dut.ct.count.value*= `0xff`, and after one rising edge clock pulse ``*dut.ct.count.value*= `0xfe`
  - Expected Output: After one clock pulse ``*dut.ct.count.value*= `0x01`
  - Observed Output: After one clock pulse ``*dut.ct.count.value*= `0xfe`
  - Error Output: ``Decrement counting-- ERROR``
 
- Input Capture Module Test:
  - Value Register Reset Test:
    - After setting the *rstVal* port high the *val* register should be reset to 0x00 but in this buggy design *val* register resets to a value of  0x1
    - Expected Output:``val = 0x0`` 
    - Observed Output in the DUT ``val=0x1``
    - Error Output: `` Val Register reset fault-- ERROR``
  - Captured *val* register Test:
    - After giving an input pulse to *sig* port the *val* register should be equal to the current *count* value of the counter module but instead the *val* stays at 0x1
    - Expected Output:``val = dut.ct.count.value`` 
    - Observed Output in the DUT ``val=0x1``
    - Error Output: `` Signal input Capture fault-- ERROR``
    
  - Interrupt Flag Reset Test:
    - After setting the *rstIntFlag* port high the *intFlag* register should be reset to 0x00 but in this buggy design *intFlag* register does not reset but stays in its previous state
    - Expected Output :``intFlag = 0x0`` 
    - Observed Output in the DUT ``intFlag=0x1``
    - Error Output: `` Interrupt Flag Reset functioning -- ERROR``


Output mismatches for the above tests prove that there are design bugs in both the counter module and the input_capture module in the design.

## Design Bug
Based on the above test inputs and analysing the design, we see that in the counter module the counting does not increment with each clock pulse, but decrements by one for each clock pulse which is a design bug, which can be seen in the following code snippet
```
 always@(posedge clk ) begin
    if(reset)    //Set Counter to Zero
      count <= 0;
    else
      count <= count - 1; //===> bug should be count<=count+1
  end
```

In the input_capture module there are three design bugs, namely *val* register reset working incorrectly, *val* register does not match with the current count value of the counter module and the *intFlag* reset is also working incorrectly.
*Val* register reset bug:
```
  always@(posedge sig or posedge rstVal or posedge rstIntFlag) begin
    if(rstVal)
      	val<= 1; //===>bug, should be zero
```
*val* register bug:
```
 else begin
    	             //===>bug, val<=tempCount; should be present
      	intFlag<=1'b1;
```
*intFlag* reset bug:
```
     	intFlag<=1'b1;
    end
        //===>bug, if(rstIntFlag) intFlag<=1'b0; should be present
```
All other operations are correct, as the expected output matches the observed output from the dut, for all the tests.

## Design Fix
Updating the design and re-running the test makes the test pass.

![image](https://user-images.githubusercontent.com/41202066/182036824-6880e077-7032-4092-b213-a402281e5792.png)

The updated design is checked in as input_capture.v in *correct_design* directory in *level3_design*
## Verification Strategy
The verification method is divided into two parts, checking the counter module and checking the working of the input_capture module. For the counter module the reset functionality is tested which comes out as working correctly. But for the the count value for each clock pulse the counter actually decrements its value, which is clearly a bug.
For the input_capture module all the functions are tested, out of which the *val* register reset, *val* register count and the *intFlag* reset functions are actually buggy as the observed output does not match the expected output.

For each tests, an error counter is incremented each time a faulty instruction code is detected.
Finally an assert statement checks if the error counter is equal to zero, if false the assert statement raises an assertion error indicating that the dut has failed. The figure below shows the failing tests.

![image](https://user-images.githubusercontent.com/41202066/182036750-e5f0bffa-f8d1-47c9-9138-6ce2f9552c38.png)

## Is the verification complete ?
Yes.
After running both the tests on the dut, both raises an Assertion error for each of the two tests giving ``one`` error for the counter module and ``three`` errors for the input_capture module.
Fixing the design bugs:
```
  always@(posedge clk ) begin
    if(reset)    //Set Counter to Zero
      count <= 0;
    else
      count <= count + 1; //corrected
```
```
  always@(posedge sig or posedge rstVal or posedge rstIntFlag) begin
    if(rstVal)
      	val<=4'b0; //corrected
```
```
    else begin
    	val<=tempCount; //corrected
      	intFlag<=1'b1;
```
```
    end
    if(rstIntFlag)
      intFlag<=1'b0; //corrected
```
After correcting the bugs in the design and running the same tests on the corrected design, the tests come out successful with zero errors.
Thus the verification is complete and all the bugs are found.
