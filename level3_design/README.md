# Level3 Design Verification

The verification environment is setup using [Vyoma's UpTickPro](https://vyomasystems.com) provided for the hackathon.

![gitpod ss](https://user-images.githubusercontent.com/110148281/181936152-339063ff-ddb9-439e-96a1-888baae0a9c8.png)

## Verification Environment

The [CoCoTb](https://www.cocotb.org/) based Python test is developed as explained. The test drives inputs to the Design Under Test (input_capture module here) which takes in clock through *clk* and input signal through *sig* port. The dut gives 8-bit value of the timestamped captured input signal through *val* output port. For each input signal captured, the dut outputs a timestamped value and sets an interrupt flag through the *intFlag* port.

The timestamping of the captured signal is done through a counter module which counts from 0 to 255 for each clock cycle.

The clock is generated by:
```
# clock
clock = Clock(dut.ct.clk, 10, units="ns")  # Create a 10us period clock on port clk
cocotb.start_soon(clock.start())  # Start the clock
```
To check the reset functionality of the counter module the following code is executed
```
# reset the counter to start
await RisingEdge(dut.ct.clk)
dut.ct.reset.value = 1
await RisingEdge(dut.ct.clk)
dut.ct.reset.value = 0
```
To check if the counter is counting correctly:
```
dut.ct.reset.value = 0
await RisingEdge(dut.ct.clk)
first=dut.ct.count.value
await RisingEdge(dut.ct.clk)
second=dut.ct.count.value
await RisingEdge(dut.ct.clk)
third=dut.ct.count.value
```
Checking the input_capture module functionality
```
    InterruptFlag_before_signal = dut.intFlag.value
    await RisingEdge(dut.ct.clk)
    dut.sig.value = 1
    await Timer(1) 
    current_count=dut.ct.count.value
    current_sig_val=dut.val.value
    InterruptFlag_after_signal = dut.intFlag.value
    await RisingEdge(dut.ct.clk)
    dut.sig.value = 0
```
Checking Interrupt flag by
```
# checking Interrupt Flag Reset
    await RisingEdge(dut.clk)
    dut.rstIntFlag.value=1
    await Timer(1)
    InterruptFlag_after_signal_after_reset=dut.intFlag.value
```

To check whether the input capture is working correctly the *sig* line is set after an arbitrary clock rising edge. The if statement is used to compare the dut's captured *val* register with the current count value of the counter module. If these values differ, an error is detected and a counter variable starts to count, how many times an error is detected.

To raise an assertion error, the assert statement is used for comparing the error counter to 0.
If the design is error free the error counter must have 0 errors, but in this case there are few errors which can be seen from the output.
The following error is seen:
- Counter module Test
```
 0.00ns INFO     running test_counter_block (1/2)
    40.00ns INFO     ##### Counter Test ########
    40.00ns INFO     Counter Reset OK
    40.00ns INFO     Decrement counting-- ERROR
    40.00ns INFO     test_counter_block failed
                     Traceback (most recent call last):
                       File "/workspace/challenges-pramitpal/level3_design/test_input_capture.py", line 65, in test_counter_block
                         assert errors == 0, f'There are {errors} faults, in Counter Module'
                     AssertionError: There are 1 faults, in Counter Module
```
- Input Capture Module Test
```
40.00ns INFO     running test_input_capture_module (2/2)
    60.00ns INFO     Signal input Capture fault-- ERROR
    70.00ns INFO     Val Register reset fault-- ERROR
    70.00ns INFO     Interrupt Flag functioning -- OK
    80.00ns INFO     Interrupt Flag Reset functioning -- ERROR
    80.00ns INFO     test_input_capture_module failed
                     Traceback (most recent call last):
                       File "/workspace/challenges-pramitpal/level3_design/test_input_capture.py", line 126, in test_input_capture_module
                         assert errors ==0,f'There are {errors} faults for Signal Input Capture'
                     AssertionError: There are 3 faults for Signal Input Capture
```

## Test Scenario **(Important)**
- Fixed value Test with Varied Instructions:
  - Test src Inputs: ``mav_putvalue_src1=0xea45f207``,  ``mav_putvalue_src2=0xc3985fa2``,`` mav_putvalue_src3=0x9f09f908``
  - Expected Output:``mav_putvalue = 0x508b400b`` 
  - Observed Output in the DUT ``dut.mav_putvalue=0x18400a405``
  - Failing instrucion : ``mav_putvalue_instr=0x40007033`` or ``mav_putvalue_instr = 0b01000000000000000111000000110011``
  - Corresponding Operation ``--ANDN``
 
- Varied value Test with Varied Instructions (Few of the varied instructions are given here):
  - Input sequence 1:
    - Test src Inputs: ``mav_putvalue_src1=0x20000000``,  ``mav_putvalue_src2=0x80000``,`` mav_putvalue_src3=0x8000000``
    - Expected Output:``mav_putvalue = 0x40000001`` 
    - Observed Output in the DUT ``dut.mav_putvalue=0x1``
    - Failing instrucion : ``mav_putvalue_instr=0x40007033`` or ``mav_putvalue_instr = 0b01000000000000000111000000110011``
    - Corresponding Operation ``--ANDN``
  - Input sequence 2:
    - Test src Inputs: ``mav_putvalue_src1=0x20000000``,  ``mav_putvalue_src2=0x80000``,`` mav_putvalue_src3=0x10000000``
    - Expected Output:``mav_putvalue = 0x40000001`` 
    - Observed Output in the DUT ``dut.mav_putvalue=0x1``
    - Failing instrucion : ``mav_putvalue_instr=0x40007033`` or ``mav_putvalue_instr = 0b01000000000000000111000000110011``
    - Corresponding Operation ``--ANDN``
  - Input sequence 3:
    - Test src Inputs: ``mav_putvalue_src1=0x20000000``,  ``mav_putvalue_src2=0x80000``,`` mav_putvalue_src3=0x20000000``
    - Expected Output:``mav_putvalue = 0x40000001`` 
    - Observed Output in the DUT ``dut.mav_putvalue=0x1``
    - Failing instrucion : ``mav_putvalue_instr=0x40007033`` or ``mav_putvalue_instr = 0b01000000000000000111000000110011``
    - Corresponding Operation ``--ANDN``


Output mismatches for the above inputs proving that there is a design bug

## Design Bug
Based on the above test inputs and analysing the design, we see that in all the tests only for  ``mav_putvalue_instr=0x40007033`` or ``mav_putvalue_instr = 0b01000000000000000111000000110011`` the dut fails. The corresponding operation for this instruction is the ``ANDN`` operation. For both fixed input values test and varied input values test the ``ANDN`` operations emerges as the bug in the design, as the expected output obtained from the model file does not match the output from the dut for this instruction.
All other operations are correct, as the expected output from the model matches the observed output from the dut, for all the tests.
## Design Fix
Updating the design and re-running the test makes the test pass.

![image](https://user-images.githubusercontent.com/41202066/182036824-6880e077-7032-4092-b213-a402281e5792.png)

The updated design is checked in as mux_fix.v in *correct_design* directory in *level3_design*
## Verification Strategy
The verification method is divided into two parts, namely a fixed input test with varied instructions and a varied input test with varied instructions.
In the first test input test, three 32-bit random numbers are generated which stays constant throughout the entire test. For checking each instructions possible, a list of possible instruction codes are generated by varying *opcode*, *f3* and *f7* portions of the instruction code. This results in a list of possible instructions. Each of these instruction codes is cross checked with the model given to verify which instructions are working correctly and which are faulty.

For the second test method, ie. varied input value with varied instructions test, each of the instruction codes for the operations given in the model file, is checked with varying input operands for all three 32-bit inputs. The varying inputs are devised such that all the bits of the inputs are checked to detect bugs. The inputs are varied like ``mav_putvalue_src1=0x0``, ``mav_putvalue_src1=0x1``, ``mav_putvalue_src1=0x2``,``mav_putvalue_src1=0x4``, ``mav_putvalue_src1=0x8`` and so on till ``mav_putvalue_src1=0x80000000``. Basically, each bit of the input ports is checked by shifting a single 1 bit towards left until all 32-bit is covered. This is done for all three inputs ie. *mav_putvalue_src1*, *mav_putvalue_src2* and *mav_putvalue_src3*.

For each tests, an error counter is incremented each time a faulty instruction code is detected.
Finally an assert statement checks if the error counter is equal to zero, if false the assert statement raises an assertion error indicating that the dut has failed. The figure below shows the failing tests.

Both these two tests give a faulty instruction code  ``mav_putvalue_instr=0x40007033`` or ``mav_putvalue_instr = 0b01000000000000000111000000110011`` which is the ``--ANDN`` operation. 
The log results of the tests are given in the figure below and more detailed test logs are given in ``test_varied_inputs.log`` and ``test_varied_instr.log`` files.

![image](https://user-images.githubusercontent.com/41202066/182036750-e5f0bffa-f8d1-47c9-9138-6ce2f9552c38.png)

## Is the verification complete ?
Yes.
After running both the tests on the dut, both raises an error for the instruction ``mav_putvalue_instr=0x40007033`` or ``mav_putvalue_instr = 0b01000000000000000111000000110011`` or the ``--ANDN`` instruction.
All other instruction codes runs successfully without any errors.
